# 이슈

1. 분명히 3초동안 스크롤을 막는 코드를 짰는데 작동하지 않았다.
2. alphabet이 svg 파일(반응형으로 브라우저창 크기에 따라 변한다.)
3. 애니메이션이 끊기고 부드럽지가 않다.
4. 부드러운 스크롤을 어떻게 구현할지 고민했다.
5. 처음 페이지 렌더링 시, 스크롤 이벤트가 발생하지 않도록 코드 작성이 필요한데. 마우스 가운데 버튼을 눌러 휠 커서로 바꾼 후 움직이는 일까진 막지 못했다.

# 경과

1. 문서 수준 대상(window.document, window.document.body 또는 window)에 등록된 휠/마우스휠 이벤트 리스너는 달리 지정하지 않으면 패시브로 처리되고 이러한 리스너 내부에서 preventDefault()를 호출하면 무시됩니다. 이는 Chrome 56에 제공된 스크롤링 개입의 휠 버전입니다.https://developers.google.com/web/updates/2017/01/scrolling-intervention
2. 똑같은 모양은 못 찾았지만, 대신에 letter를 svg 파일로 가진 라이브러리 @icongo/tb를 찾았다.
3. motion-framer를 써봤다.
4. motion-framer로 해결하려고 했지만 해답을 찾지 못했고, 한 번 원본 페이지에서 scroll이라는 키워드로 찾아봤다.
5. lenis 라이브러리를 둘러보고, 관련 window 메서드도 찾아봤지만 찾지 못했다. 그래서 원본 페이지는 어떻게 해결했나 확인해봤고, 그 결과 요소가 영역을 차지하고 있지 않은 일을 확인했다..

   - useEffect, createRoot와 setTimeout을 조합해 시간차로 렌더링하는 법을 고려했지만, 요소들의 렌더링 자체는 이미 되어있고 그 속성값이 변하는 일을 확인할 수 있었다.

# 결과

1. preventDefault() 말고도 addEventListener에 추가적인 매개변수에 옵션으로 passive:false를 추가해줘야 했다.
2. 소문자 svg 파일을 가진 라이브러리를 찾아봤지만 찾지 못했다. 추측이지만 svg 요소 작성에 시간은 걸리지만, 알파벳이라 복잡하진 않은 모양이니 스스로 작성한걸로 추측한다. 원본 페이지에서 svg 파일을 따올수도 있지만, 나는 그냥 라이브러리를 활용해서 진행하도록 했다.
3. 가볍게 만들려고 keyframes로 애니메이션을 처리했지만, motion framer로 작성한 애니메이션이 부드러웠다. 대신 motion framer를 활용하자 로딩시간이 길어졌다. 경우에 따라서 다르게 써주면 될 듯 싶다.
4. 원본 페이지에서 lenis라는 단어를 찾았다. 원본 페이지의 코드 곳곳에 본인 이름을 새겨놓은 개발자였고, 그래서 뭔가 이상하다고 여겨 lenis를 검색해보니 스크롤 라이브러리가 존재했다.
5.
